# SM3加密算法
20220818




## SM3

SM3密码杂凑算法采用Merkle-Damgard结构，消息分组长度为512b，摘要长度256b。压缩函数状态256b，共64步操作步骤.
对长度为l($l < 2^{64}$) 比特的消息m，SM3杂凑算法经过填充和迭代压缩，生成杂凑值，杂凑值长度为256比特。
-   填充补位，按512bit分组   
-   512bit组内扩展+压缩    
-   迭代

#### SM2算法流程-填充
对输入的长度为l比特消息m，在原始数据末尾进行填充，，使数据长度= 448 （mod 512），规则为先补第一个比特为1，然后都补k个0，使得填充后的序列满足，$（l+1+k） mod 512 =448$(k是满足该等式的最小非负整数)；若m本身长度刚好为448也必须填充，此时需要增加1位1和511位0；然后再在序列末尾添加一个原始数据的长度信息（无符号整数64bit)

 

#### SM2算法流程-迭代
##### 迭代过程
将填充后的消息m′按512比特进行分组：$m′ = B^{(0)}B^{(1)}· · · B^{(n-1)}$
其中n=(l+k+65)/512。
对m′按下列方式迭代：
-   *FOR i=0 TO n-1
    $V^{(i+1)} = CF(V^{(i)}, B^{(i)})$
    ENDFOR*

其中CF是压缩函数，V(0)为256比特初始值IV,$$IV =7380166f 4914b2b9 172442d7 da8a0600 a96f30bc 163138aa e38dee4d b0fb0e4e$$B(i)为填充后的消息分组，迭代压缩的结果为$V^{(n)}$。

##### 消息扩展
将消息分组$B^{(i)}$按以下方法扩展生成132个字$W_0,W_1, · · · , W_{67}, W_0′, W_1', · · · , W_{63}′$，用于压缩函数CF：
-   *a)将消息分组$B^{(i)}$划分为16个字$W_0, W_1, · · · , W_{15}$。
    b)FOR j=16 TO 67
   $ W_j ← P_1(W_{j−16} ⊕ W_{j−9} ⊕ (W_{j−3} <<< 15)) ⊕ (W_{j−13} <<< 7)⊕ W_{j−6}$
    ENDFOR
    c)FOR j=0 TO 63
    $W_j' = W_j ⊕ W_{j+4}$
    ENDFOR*

TIPS: <<<循环左移，⊕按位异或
其中$P_1(X)=X \oplus (X<<<9)\oplus (X<<<7)$

##### 压缩函数
令A,B,C,D,E,F,G,H为字寄存器,SS1,SS2,TT1,TT2为中间变量,压缩函数$V^{i+1} = CF(V^{(i)}, B^{(i)}), 0 ≤i ≤ n−1$。计算过程描述如下：

-   $ABCDEF GH ← V^{(i)}$
-   FOR j=0 TO 63
    $ \ \ \ \  SS1 ← ((A <<< 12) + E + (T_j <<< j)) <<< 7$
    $ \ \ \ \ SS2 ← SS1 ⊕ (A <<< 12)$
    $ \ \ \ \ T T1 ← F Fj (A, B, C) + D + SS2 + W_j'$
    $ \ \ \ \ T T2 ← GGj (E, F, G) + H + SS1 + W_j $
    $ \ \ \ \ D ← C$
    $ \ \ \ \ C ← B <<< 9$
    $ \ \ \ \ B ← A$
    $ \ \ \ \ A ← T T1$
    $ \ \ \ \ H ← G$
    $ \ \ \ \ G ← F <<< 19$
    $ \ \ \ \ F ← E$
    $ \ \ \ \ E ← P_0(TT2)  $
ENDFOR
-   $V^{(i+1)} ← ABCDEF GH ⊕ V^{(i)}$


其中$P_0(X)=X \oplus (X<<<9)\oplus (X<<<17)$
其中，
$  {FF_j (X, Y, Z)=}
                \left\{
                        \begin{aligned}
                        &X ⊕ Y ⊕ Z \ \ , 0 ≤ j ≤ 15\\
                        &(X ∧ Y ) ∨ (X ∧ Z) ∨ (Y ∧ Z ) \ \ ,16 ≤ j ≤ 63
                        \end{aligned}
                \right.
$
$  {GG_j (X, Y, Z)=}
                \left\{
                        \begin{aligned}
                        &X ⊕ Y ⊕ Z \ \ , 0 ≤ j ≤ 15\\
                        &(X ∧ Y ) ∨ ( ¬X∧ Z) \ \ ,16 ≤ j ≤ 63
                        \end{aligned}
                \right.
$

其中X,Y,Z 为字,⊕32位异或，∧32位与，∨32位或，¬32位非,+:$mod\ 2^{32}$比特算术加运算,$T_j$为预设常数
其中，字的存储为大端(big-endian)格式，左侧为高位，右侧为低位
#### 杂凑值
$ABCDEF GH ← V^{(n)}$
输出256比特的杂凑值y = ABCDEFGH。
 


#### SM2 资源消耗部分相关
涉及到的运算操作 ⊕32位异或，∧32位与，∨32位或，¬32位非,+:$mod\ 2^{32}$比特算术加运算，<<<32位循环移位
#### 计算的关键路径
计算下一轮的 A，首先得先计算SS1，而 SS1 需要计算 2 次加法获得，由 SS1 到 TT1的求解过程，又有 32 次加法计算，所以计算下一轮的A 需要有 5 次加法，及与或非和移位等运算。同样，计算下一轮 E 的过程也需要 5 次的加法
- A的更新：32位逻辑运算、——> 32为算术比特加




## SHA256
散列函数是把消息压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫散列值的指纹。
散列值通常用一个短的随机字母和数字组成的字符串代表。
对于任意长度的消息，SHA256都会产生一个256bit长度的散列值，称为消息摘要，可以用一个长度为64的十六进制字符串表示。
### SHA256算法流程

#### 填充
同SM2填充
#### 迭代
将填充处理后的消息以512位为单位分块为$M^{(1)},M^{(2)},...,M^{(N)}$。其中第i个消息块的前32位表示为$M_0^{(i)}$:, 第二个32位为$M_1^{(i)}$:, 以此类推, 最后32位的消息块可表示为$M_{15}^{(i)}$:



$
Ch(x,y,z)=(x \land y ) \oplus (\neg x \land z) \\
M_{a,j}(x,y,z)=(x \land y ) \oplus ( x \land z)\oplus ( y \land z)\\
\sum_0(x)=S^2(x)\oplus S^{13}(x) \oplus  S^{22}(x)\\
\sum_1(x)=S^6(x)\oplus S^{11}(x) \oplus  S^{25}(x)\\
\sigma_0(x)=S^7(x)\oplus S^{18}(x) \oplus  R^{3}(x)\\
\sigma_1(x)=S^{17}(x)\oplus S^{19}(x) \oplus  R^{10}(x)\\$
$S^N$表示循环右移N位，$R^N$表示右移N位



##### 消息扩展
   *a)将消息分组$M^{(i)}$划分为16个字$M_0, M_1, · · · , M_{15}$
   。$W_j=M_j,  for \ j = 0 \rarr 15$
    b)FOR j=16 TO 43
   $ W_j =\sigma_1(W(j-2)) + W(j-7) + \sigma_0(w(j-15)) + W(j-16)$
    ENDFOR


##### 压缩函数
令A,B,C,D,E,F,G,H为字寄存器,T1,T2为中间变量,压缩函数$H^{i+1} = CF(H^{(i)}, M^{(i)}), 0 ≤i ≤ n−1$。计算过程描述如下：


-   FOR j=0 TO 63
    $ \ \ \ \ T1 ← H+\Sigma_1(E)+Ch(e,f,g)+K_j+W_j$
    $ \ \ \ \ T2 ← \Sigma_0 (A) + M_{a,j}(A,B,C) $
    $ \ \ \ \ D ← C$
    $ \ \ \ \ C ← B$
    $ \ \ \ \ B ← A$
    $ \ \ \ \ A ←  T1+T2$
    $ \ \ \ \ H ← G$
    $ \ \ \ \ G ← F $
    $ \ \ \ \ F ← E$
    $ \ \ \ \ E ← D+T1  $
ENDFOR


![SHA-256压缩函数框图](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220927163600.png)


计算第i个中间哈希值$H^{(i)}$
$
H_1^{(i)} \larr a +H_1^{(i-1)}\\
H_2^{(i)} \larr B +H_2^{(i-1)}\\
...\\
H_8^{(i)} \larr h +H_8^{(i-1)}\\$
```C
初始哈希值
	H0 := (0x6a09e667)
	H1 := (0xbb67ae85)
	H2 := (0x3c6ef372)
	H3 := (0xa54ff53a)
	H4 := (0x510e527f)
	H5 := (0x9b05688c)
	H6 := (0x1f83d9ab)
	H7 := (0x5be0cd19)

常数
k := [64]uint32{
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2}
        
```
#### 杂凑值

最后输出256比特的杂凑值$H^{(N)}=(H_1^{(1)},H_2^{(2)},...,H_8^{(N)})$。

