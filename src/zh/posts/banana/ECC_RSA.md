# ECC RSA  算法

## ECC
[参考](https://zhuanlan.zhihu.com/p/66794410)
椭圆曲线难题
K=kG，其中K,G为Ep（a,b）上的点，k为小于n的整数，n是点G的阶，给定k和G，计算K容易，但是给定K和G，求k就很难了！

因此，设K为公钥，k为私钥，G为基点。

 
### ECC加解密过程
加密过程
A选定一条椭圆曲线Ep（a,b），并取曲线上一点作为基点G
A选择一个私钥k，并生成公钥K=kG
A将Ep（a,b）和K，G发送给B
B收到后将明文编码到Ep（a,b）上一点M，并产生一个随机数r
B计算点C1=M+rK，C2=rG
B将C1，C2传给A
A计算C1-kC2=M+rkG-krG=M
A对M解码得到明文
攻击者只能得到Ep（a,b），G，K，C1，C2，没有k就无法得到M。


签名验签流程
A选定一条椭圆曲线Ep（a，b），并取曲线上一点作为基点G
A选择一个私钥k，并生成公钥K=kG
A产生一个随机数r，计算R(x,y)=rG
A计算Hash=SHA(M)，M‘=M(modp)
A计算S=（Hash+M'k）/r(modp)
B获得S和M'，Ep(a,b)，K，R(x,y)
B计算Hash=SHA(M)，M'=M(modp)
B计算R'=（Hash*G+M'*K）/S=(Hash*G+M'*kG)*r/(Hash+M'k)=rG=R（x,y），若R'=R，则验签成功。
以上加解密和签名验签流程只是一个例子，具体应用时可以利用K=kG这一特性变幻出多种加解密方式。



####    ECCDSA

Alice 想要使用她的私钥  来签名，Bob 想用 Alice 的公钥  要验证签名，只有 Alice 才能提供正确的签名，而每个人都可以验证签名

ECDSA 是 DSA 作用于椭圆曲线的一个变种算法。Alice 和 Bob 仍然使用同样的曲线，ECDSA 需要使用明文的哈希结果，而不是明文本身。哈希函数的选择取决于使用者，但是需要明确的是必须选择加密安全的哈希函数，为了使哈希结果的比特长度和 n （子群的阶）的比特长度一致，消息的哈希结果需要被截断，被截断后的哈希值会是一个整数，我们用z来表示

##### ECDSA生成签名
> Alice 使用算法来签名的步骤如下：
1. 在[1,n-1]范围内选取一个随机数k（n是子群的阶）
2. 计算点P=kG （G是子群的基点）
3. 计算数字$r=x_p \ mod \ n $（$x_p$是p的x轴坐标）
4. 如果r=0，另选一个k并重新计算
5. 计算$s=k^{-1}(z+r d_A)\ mod \ n$  （ $d_A$是Alice的私钥，$k^{-1}$ 是$k \ mod \ n$ 的乘法逆元）

__(r,s)即为数字签名__


![20220924152415](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220924152415.png)
##### ECDSA验证签名
为了验证签名，我们需要 Alice 的公钥$H_A$  ，被截断的哈希值z，还有签名(r,s)
1. 计算整数$u_1=s^{-1} z \ mod \ n$
2. 计算整数$u_2=s^{-1} r \ mod \ n$
3. 计算点$P=u_1G+u_2 H_A$ 
   
   
iff __$r=x_p \ mod \ n$__,ECCDSA vertification passed


##### ECDSA原理推导
通俗的说，这个算法一开始生成了 k，得益于点乘（这是一个数学困难问题）k 被隐藏在了 r 中，然后通过等式$s=k^{-1}(z+r d_A)\ mod \ n$  将 r 绑定到了消息散列值上。

为了计算 s，我们必须计算 k 的逆 mod n，在之前的文章中说过只有在 n 是素数的情况下才能保证这一过程，如果子群的阶不是一个素数，ECDSA 将不起作用。几乎所有标准的曲线都是素数阶的，这肯定不是巧合，非素数阶的那些曲线是不能被 ECDSA 使用的。

1. 从验签者Bob的P的生成出发
   $ \begin{aligned} 
   P&=u_1G+u_2 H_A\\
   &=u_1G+u_2 d_2 G\\
   &=(u_1+u_2d_a)G\\
   &=(s^{-1} z+s^{-1}r d_A)G\\
   &=s^{-1}(z+r d_A)G
   \end{aligned}$
2. 在Alice中有$s=k^{-1}(z+r d_A)\ mod \ n$，进行变换得到$k=s^{-1}(z+r d_A)\ mod \ n$,得到双方求得的是同一点的P
      $ \begin{aligned} 
   P&=s^{-1}(z+r d_A)G\\&=kG
   \end{aligned}$


#### ECDH椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange）
主要是用来在一个不安全的通道中建立起安全的共有加密资料，一般来说交换的是通过不安全信道中各自的公钥，并各自计算生成一个秘密共享密钥——这个秘密共享密钥多用于对称加密。


>ECDH
1. __Alice 和 Bob 生成各自的私钥和公钥__，Alice 的私钥为$d_A$，公钥为$H_A=d_A G $  。Bob 的私钥为$d_B$，公钥为$H_B=d_B G $  ，注意，Alice和Bob 需要使用一样的主要参数：在同一条曲线的同一个有限域上选择一样的基点G。
2. __Alice 和 Bob 通过不安全信道交换各自的公钥$H_A \ \  H_B $__,中间人可以窃听到$H_A \ \  H_B$，但是在无法攻破离散对数难题的情况下无法得到$d_A$和$d_B$。
3. __Alice 计算$S=d_A H_B$__,__Bob计算$S=d_B H_A$__,双方求得的S是相同的,$\\ S=d_A H_B=d_A(d_BG)=d_B(d_AG)=d_B H_A$

## RSA

RSA基于一个十分简单的数论事实：将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用。

欧拉函数$\varphi(n)$表示小于或等于n的正整数中与 n 互质的数的数目
欧拉定理：若a,m均为正整数,且gcd(a,m)=1,则$a^{\varphi(m)}≡1(mod \ m)$

#### RSA加解密过程

##### 密钥生成
1. 随机选择两个不相同的素数 p,q。
2. 将 p,q 相乘，记为 n=p×q。
3. 计算n的欧拉函数$\varphi(n)$，欧拉函数证明，当 p,q 为不相同的素数时,$\varphi(n) = (p-1)(q-1)$。
4. 随机选择一个整数e ，满足两个条件：$\varphi(n)$与 e 互质，且 $1<e<\varphi(n)$ 。
5. 计算e对于 $\varphi(n)$的模反元素d，也就是说找到一个d满足 $ed = 1 \ mod\ \varphi(n)$。这个式子等价于$ed-1=k\varphi(n)$ ，实际上就是对于方程$ed-k \varphi(n)=1$求(d,k) 的整数解。这个方程可以用扩展欧几里得算法求解。
6. 最终把(e,n)封装成公钥(d,n)封装成私钥。

##### 加密过程
1. 发送方获得公钥对{e,n}
2. 把明文m分解为小于n的若干块
3. 计算密文$  C=m^e\mod n$


##### 解密过程
1. 接收方提前内置密钥对{d,n}
2. 对密文解密$ m=C^d\mod n$

#### RSA数字签名

签名生成：
> 对消息M进行签名，计算$$s=Sig(h(m))=(h(m))^d \ mod \ n$$,传递(M,s)

签名校验：
>给定(M,s)，验证$$h(m)=s^e \ mod \ n $$