# SM2 SM9 ECC Alg
20220817

### 1. background
- 可以在二元扩域和素数域中实现

总则中对于素数域一般用仿射坐标进行描述



#### 1.1. 有限域上的椭圆曲线
对于素数域$F_p,p>3$,曲线方程定义为$$ 
 y^2=x^3 + ax + b \ (mod) \ p,  \quad a,b \in F_p \ ,4a^3 + 27 b^2 \neq 0 \ \ mod \ p  \tag{1.1}  
$$

用符号$E(F_p)$表示椭圆曲线，定义为$$
E(F_p)=\{ (x,y)|x,y \in F_p \& 满足公式 (1) \}
$$



#### 1.2. 二元扩域上的椭圆曲线
对于素数域$F_{2^m}$,曲线方程定义为$$ 
 y^2+xy=x^3 + ax + b \ (mod) \ p,  \quad a,b \in F_{2^m}, 4a^3 + 27 b^2 \neq 0 \ \ mod \ p  \tag{1.2}  
$$

二元扩域上算法不限制对于$F_{2^m}$的元素表示（三项式基TPB、五项式PPB、高斯正规基GNB）

#### 1.3. 密钥对的生成
- 输入：$一个有效的Fq(q = p且p为大于3的素数，或q = 2^m
)上椭圆曲线系统参数的集合$
- 输出：$与椭圆曲线系统参数相关的一个密钥对(d,P)。$
  - 用随机数发生器产生整数d ∈ [1,n−2]
  -  G为基点，计算点P = (xP,yP) = [d]G
  - 密钥对是(d,P)，其中d为私钥，P为公钥

### 2. 数字签名算法
数字签名算法由一个签名者对数据产生数字签名，并由一个验证者验证签名的可靠性。每个签名者有一个公钥和一个私钥，其中私钥用于产生签名，验证者用签名者的公钥验证签名。在签名的生成过程之前，要用密码杂凑函数对M (包含$Z_A$和待签消息M)进行压缩；在验证过程之前，要用密码杂
凑函数对$M^′$(包含$Z_A'$和验证消息M′)进行压缩

### 3. SM2

#### 3.1. SM2 数字签名的生成算法
##### 3.1.1. Pre-DATA $Z_A$
> 作为签名者的用户A具有长度为$entlen_A$比特的可辨别标识$ID_A$，记$ENTL_A$是由整数$entlen_A$转换而成的两个字节，在本部分规定的椭圆曲线数字签名算法中，签名者和验证者都需要用密码杂凑函数求得用户A的杂凑值$Z_A$。按SM2标准的通则，将椭圆曲线方程参数a、b、G的
坐标xG、yG 和PA的坐标$x_A$、$y_A$的数据类型转换为比特串，
$$Z_A=H_{256}(ENTL_A ∥ ID_A ∥ a ∥ b ∥ x_G ∥
y_G ∥ x_A ∥ y_A)$$
##### 3.1.2. SM2 DSA generation Alg
设待签名的消息为M，为了获取消息M的数字签名(r,s)，作为签名者的用户A应实现以下运算步骤：,其中$P_A=[d_A]G=(xA,yA)$
1. 置$ \overline{M}=Z_A ∥ M$；
2. 计算$e = H_v(\overline{M})$，按通则中的细节将e的数据类型转换为整数；
3. 用随机数发生器产生随机数k ∈[1,n-1]；
4. 计算椭圆曲线点(x1,y1)=[k]G，按通则将x1的数据类型转换为整数；
5. 计算$r=(e+x1) modn$，若r=0或r+k=n则返回3.；
6. 计算$s = ((1 + d_A)^{−1}· (k − r · d_A)) mod \ n$，若s=0则返回3.
7. 按通则将r、s的数据类型转换为字节串，消息M的签名为(r,s)。
![20220825180041](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220825180041.png)

##### 3.1.3. SM2 DSA verification  Alg

为了检验收到的消息M′及其数字签名(r′, s′)，作为验证者的用户B应实现以下运算步骤：
1. 检验r′ ∈[1,n-1]是否成立，若不成立则验证不通过；
2. 检验s′ ∈[1,n-1]是否成立，若不成立则验证不通过；
3. 置$M′=Z_A ∥ M′$；
4. 计算$e′ = H_v(M′)$，按本文本第1部分4.2.3和4.2.2给出的细节将e′的数据类型转换为数；
5. 按本文本第1部分4.2.2给出的细节将r′、s′的数据类型转换为整数，计算t = (r′ + s′)modn，若t = 0，则验证不通过；
6. 计算椭圆曲线点$(x_1', y_1')=[s′]G + [t]P_A$；
7. 按本文本第1部分4.2.7给出的细节将x′1的数据类型转换为整数，计算$R = (e′ + x_1') mod\ n$，检验R=r′是否成立，若成立则验证通过；否则验证不通过
![20220825181421](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220825181421.png)

#### 3.2. SM2 密钥交换
> **密钥交换**
>> 密钥交换协议是两个用户A和B通过交互的信息传递 ,用各自的私钥和对方 的公钥来商定一个只有他们知道的秘密密钥。这个共享的秘密密钥通常用在某个对称密码算法中。该密钥交换协议能够用于密钥管理和协商 。

![20220825181646](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220825181646.png)

>第一阶段 :产生临时密钥对
- 用户 A:
调用生成密钥算法产生临时密钥对 $(r_A ,R_A )$,将$R_A$和用户A的用户身份标识$ID_A$发送给用户B。
- 用户 B:
调用生成密钥算法产生 临时密钥对 $(r_B ,R_B )$,将$R_B$和用户B的用户身份标识$ID_B$发 送给用户A。

>第二阶段 :计算共享秘密密钥

#### 3.3. SM2 公钥加密
公钥加密算法涉及三类辅助函数 :密码杂凑函数 、密钥派生函数和随机数发生器 。这三类辅助函数的强弱直接影响加密算法的安全性 。
##### 3.3.1. KDF 密钥派生函数
密钥派生函数需要调用密码杂凑函数，一般以SM3密码杂凑算法为例。
设密码杂凑函数为$H_v( )$，其输出是长度恰为v比特的杂凑值。
密钥派生函数$KDF(Z, klen)$：
输入：比特串$Z$，整数$klen$--表示要获得的密钥数据的比特长度，要求该值小于$(2^{32}-1)v$。
输出：长度为$klen$的密钥数据比特串$K$。
>a)初始化一个32比特构成的计数器ct=0x00000001；
b)对i从1到⌈klen/v⌉执行：
&emsp; b.1)计算$Ha_i=H_v(Z ∥ ct)$；
&emsp; b.2) ct++；
c)若$klen/v$是整数，令$Ha!_{⌈klen/v⌉ }= Ha_{⌈klen/v⌉}$，否则令$Ha!_{⌈klen/v⌉}$为$Ha_{⌈klen/v⌉}$最左边的$(klen −(v × ⌊klen/v⌋))$比特；
d)令$K = Ha_1||Ha_2|| · · · ||Ha_{⌈klen/v⌉−1}||Ha!_{⌈klen/v⌉}$。


##### 3.3.2. 加密算法
设需要发送的消息为比特串M，klen为M的比特长度。
为了对明文M进行加密，作为加密者的用户A应实现以下运算步骤：

- A1：用随机数发生器产生随机数k∈[1,n-1]；
A2：计算椭圆曲线点C1=[k]G=(x1,y1)，按通则将C1的数据类型转换为比特串；
A3：计算椭圆曲线点$S=[h]P_B$，若S是无穷远点，则报错并退出；
A4：计算椭圆曲线点$[k]P_B=(x2,y2)$，按通则将，将坐标x2、y2的数据类型转换为比特串；
A5：计算t=KDF(x2 ∥ y2, klen)，若t为全0比特串，则返回A1；
A6：计算C2 = M ⊕ t；
A7：计算C3 = Hash(x2 ∥ M ∥ y2)；
A8：输出密文C = C1 ∥ C2 ∥ C3。
![20220825184115](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220825184115.png)
> C1:随机数K与基点G的运算结果，结果是一个点，坐标记为(x1,y1)
> C2:实际密文值(密钥流 $\oplus$data)
> C3:使用SM3对于 kx||data||ky的hash
> *用户A使用SM2加密的时后要使用余因子h来检测B的公钥Pb*我的理解是: 在实际中余因子等于1，不需要这一步的。当余因子不等于1时，整个椭圆曲线上的点并没有构成素数阶循环群，往往就是找一个基点，把这个基点生成的循环群作为算法所工作的群，这样一来，为了验证公钥的合法性，即公钥是在基点所生成的循环群中，就需要算公钥的h倍，一旦算出得到了无穷远点，说明公钥不在由基点生成的群中(但还是在曲线上的)。这个和椭圆曲线的群结构有关系，大致可以理解为，整个椭圆曲线群同构于两个群的直积: G1× G2，G1就是我们要使用的循环群，G2就是那个余因子对应的群。https://www.zhihu.com/question/437176611


##### 3.3.3. 解密算法
设klen为密文中C2的比特长度。
为了对密文C=C1 ∥ C2 ∥ C3 进行解密，作为解密者的用户B应实现以下运算步骤：
- B1：从C中取出比特串C1，按通则，将C1的数据类型转换为椭圆曲线上的点，验证C1是否满足椭圆曲线方程，若不满足则报错并退出；
B2：计算椭圆曲线点S=[h]C1，若S是无穷远点，则报错并退出；
B3：计算[dB]C1=(x2,y2)，按通则，将坐标x2、y2的数据类型转换为比特串；
B4：计算t=KDF(x2 ∥ y2, klen)，若t为全0比特串，则报错并退出；
B5：从C中取出比特串C2，计算M′ = C2 ⊕ t；
B6：计算u = Hash(x2 ∥ M′ ∥ y2)，从C中取出比特串C3，若$u \neq C3$，则报错并退出；
B7：输出明文M′。
![20220825184418](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220825184418.png)


### 算法开销
#### 数字签名算法
![20220902111251](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220902111251.png)
### 4. SM9(To be continued)
基于标识的非对称密码算法

