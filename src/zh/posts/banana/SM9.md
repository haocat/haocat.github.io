#  SM9
基于标识的非对称密码算法
## ECC前置知识


## 总则
### 标识 identity
可唯一确定一个实体身份的信息。标识应由实体无法否认的信息组成，如实体的可识别名称、电子邮箱、身份证号、电话号码等
### 主密钥 master key
处于标识密码密钥分层结构最顶层的密钥，包括主私钥和主公钥，其中主公钥公开，主私钥由KGC
秘密保存。KGC用主私钥和用户的标识生成用户的私钥。在标识密码中，主私钥一般由KGC通过随机数发
生器产生，主公钥由主私钥结合系统参数产生。
本文中，签名系统的主密钥与加密系统的主密钥不同。数字签名算法属于签名系统，其主密钥为签
名主密钥，密钥交换协议、密钥封装机制和公钥加密算法属于加密系统，其主密钥为加密主密钥
### 密钥生成中心 key generation center；KGC
在SM9标识密码中，负责选择系统参数、生成主密钥并产生用户私钥的可信机构
###
下列符号和缩略语适用于本部分。
- cf：椭圆曲线阶相对于 N 的余因子。
- cid：用一个字节表示的曲线识别符，用以区分所用曲线的类型。
- DLP：有限域上离散对数问题。
- deg( f )：多项式 f(x)的次数。
- d1、d2：k 的两个因子。
- E：定义在有限域上的椭圆曲线。
- ECDLP：椭圆曲线离散对数问题。
- $E(F_q)$：有限域$ F_q$上椭圆曲线 E 的所有有理点(包括无穷远点 O)组成的集合。
- RE(F_q)[r]：$E(Fq)$上 r-扭点的集合(即曲线 $E(F_q)$上的 r 阶扭子群)。
- e：从 $G_1×G_2$ 到 $G_T$的双线性对。
- eid：用一个字节表示的双线性对 e 的识别符，用以区分所用双线性对的类型。
- Fp：包含 p 个元素的素域。
- Fq：包含 q 个元素的有限域。
- $Fq^*$：由 Fq中所有非零元构成的乘法群。
- $F_q^m$ ：有限域 $F_q$的 m 次扩域。
- $G_T$：阶为素数 N 的乘法循环群。
- $G_1$：阶为素数 N 的加法循环群。
- $G_2$：阶为素数 N 的加法循环群。
- gcd(x, y)：x 和 y 的最大公因子。
- k：曲线 E(Fq)相对于 N 的嵌入次数，其中 N 是#E(Fq)的素因子。
- m：有限域 $F_{q^m}$关于$F_q$的扩张次数。
- mod f(x)：模多项式 f(x)的运算。
- mod n：模 n 运算。例如，23 mod 7=2。
- N：循环群 1、 2和 T的阶，为大于 $2^{191的}$素数。
- O：椭圆曲线上的一个特殊点，称为无穷远点或零点，是椭圆曲线加法群的单位元。
- P：$P=(x_P , y_P)$ 是椭圆曲线上除 O 之外的一个点，其坐标 $x_P，y_P$满足椭圆曲线方程。
- P1：$G_1$的生成元。
- P2： $G_2$的生成元。
- P+Q：椭圆曲线 E 上两个点 P 与 Q 的和。
- p：大于 $2^{191}$的素数。
- q：有限域 Fq中元素的数目。
- xP：点 P 的 x 坐标。
- x||y：x 与 y 的拼接，其中 x 和 y 是比特串或字节串。
- x = y (mod q)：x 与 y 模 q 同余。亦即，x mod q = y mod q。
- $y_P$：点 P 的 y 坐标。
- #E(K)：E(K)上点的数目，称为椭圆曲线群 E(K)的阶，其中 K 为有限域（包括 $F_q$ 和 $F_{q^K}$)
- <_P_>：由椭圆曲线上点 P 生成的循环群。
- [u]P ：椭圆曲线上点 P 的 u 倍点。
- [x, y]：不小于 x 且不大于 y 的整数的集合。
- $\lceil x \rceil$ ：顶函数，不小于 x 的最小整数。例如， $\lceil 7 \rceil$ =7,$\lceil 8.3 \rceil$ = 9。
- $\lfloor x \rfloor$：底函数，不大于 x 的最大整数。例如,$\lfloor 7 \rfloor$ = 7,$\lfloor 8.3 \rfloor$= 8。
- $\beta$：扭曲线参数。
- $\psi$： $G_2$到 $G_1$的同态映射，满足 P1 = $\psi$(P2)。
- ⊕：长度相等的两个比特串按比特的模2加运算(异或)
- $N|q^k-1: q^k-1 \  mod \ N =0$
- hid:在密钥交换部分中用一个字节表示的加密私钥生成函数识别符，由KGC选择并公开
SM9算法主要包括密钥部分和算法部分。

密钥部分：包括主密钥对(公钥和私钥)和用户私钥
算法部分：包括签名验签算法、密钥封装解封算法、加密解密算法和密钥交换算法


密钥部分
SM9算法的密钥由KGC(密钥生成中心)产生，主要包括KGC的主密钥对和用户的私钥。
主密钥对分为签名主密钥对和加密主密钥对。

签名主密钥对：其私钥是一个在[1,N-1]范围内的随机数；公钥是G2群的基点P2的倍点，倍数为私钥。
加密主密钥对：其私钥是一个在[1,N-1]范围内的随机数；公钥是G1群的基点P1的倍点，倍数为私钥。


主密钥对的公私钥用在不同场景，其中主私钥仅用于计算用户私钥；主公钥则由KGC公开并用在其他部分。同时，签名主公钥仅用于签名和验签算法；加密主公钥则用于密钥封装、加密和密钥交换中。

用户私钥由KGC产生，包括签名私钥和加密私钥。

签名私钥：是G1群的基点P1的倍点。签名私钥仅用于签名中
加密私钥：是G2群的基点P2的倍点。加密私钥用于密钥解封、解密和密钥交换中
KGC使用主私钥和用户身份标识(以下简称ID)生成用户的私钥。

算法部分
SM9算法包括签名验签、密钥封装解封、加密解密和密钥交换四大部分。

签名算法：使用签名主公钥和签名者的签名私钥给数据签名
验签算法：使用签名主公钥和签名者ID验证签名
密钥封装算法：使用加密主公钥和密钥解封者(使用对称密钥的另一方)ID封装一个对称密钥
密钥解封算法：使用加密主公钥和密钥解封者ID解出封装了的对称密钥
加密算法：使用加密主公钥和解密者ID加密数据
解密算法：使用解密者的加密私钥和解密者ID解密数据
密钥交换算法：密钥交换双方使用加密主公钥、自己的加密私钥和双方的ID协商出一个共享密钥


用户身份标识符：ID
SM9算法中的用户身份标识ID主要用于用于私钥生成、验签、密钥封装解封、加密解密封和密钥交换。

主要应用的ID简单描叙如下：

私钥生成：ID是私钥属主的ID
验签：ID是签名者的ID
密钥封装解封：ID是解封者的ID
加密解密：ID是解密者的ID
密钥交换：发起方和响应方都需要自己的ID和对方的ID


## 数字签名
SM9数字算法的签名这持有一个标识和一个相应的签名私钥，该签名私钥由密钥生成中心通过签名主私钥和签名者的标识结合产生。签名者用自身签名私钥对数据产生数字签名，验证者用签名者的标识验证签名的可靠性。
在签名的生成和验证之前，都要用密码杂凑函数对待签名消息M和待验证消息M'进行压缩。
 
#### 密码函数H1 H2
>密码函数 H1(Z, n)：
输入：比特串 Z，整数 n。
输出：整数$h1 \isin [1, n-1]$。
- 步骤 1：初始化一个 32 比特构成的计数器 ct=0x00000001；
- 步骤 2：计算 $hlen=8\times \lceil (5 \times (log_2n))/32 \rceil$；
- 步骤 3：对 i 从 1 到 $ \lceil hlen/v \rceil$执行：
- -  步骤 3.1：计算 $Ha_i=H_v(0x01||Z||ct)$；
- - 步骤 3.2：ct++；

- 步骤 4：若 hlen/v 是整数，令 $Ha!_{\lceil hlen/v \rceil} = Ha_{\lceil hlen/v \rceil}$，
否则令$Ha!_{\lceil hlen/v \rceil} $为$Ha_{\lceil hlen/v \rceil}$最左边的$(hlen–(v \times \lfloor hlen/v \rfloor)$比特；
- 步骤 5：令 $Ha = Ha1 || Ha2 ||  Ha_{\lceil hlen/v \rceil-1} || Ha!_{\lceil hlen/v \rceil}$，将 Ha 的数据类型转换为整数；
- 步骤6：计算h1=(Ha mod (n-1))+1
>密码函数 H2(Z, n)：即把H1中步骤3.1的 $Ha_i=H_v(0x01||Z||ct)$替换为 $Ha_i=H_v(0x02||Z||ct)$

#### 

(1)利用双线性对算法计算 N 阶乘法循环群$G_T$中的元素$g=e(P_1,P_{pub-s}) $ --$P_1:群G1的生成元，P_{pub-s}：签名主公钥$；
(2)利用随机数发生器生成随机数 r，$r \isin[1,N-1]$，N是循环群$G_1 \ G_2 \ G_T$的阶；
(3)计算$G_T$里的元素,$w=g^r$，需要转换 w 数据类型成比特串；
(4)利用密码函数计算$h=H_2(m||w,N)$，h 为整数；
(5)计算$l=(r-h) mod N$ ，l为整数，若为 0 返回第二步；
(6)计算 N 阶循环子群$G_1$中的元素$s=[l]d_{sA}$；
(7)结束后可得到消息 m 签名为(h,S)。
![20220913153426](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913153426.png)
作为验签方需要检验接收的消息 m’和签名(h’,S’)是否正确，因此作为接收验证方
需要计算以下步骤：
(1)检验 h’是否属于[1,N-1]，如果不属于则验证失败；
(2)将 s’转换到曲线上的点，同时检验 s’是否属于G1，是则通过，否则终止；
(3)计算群$G_T$中的元素$g=e(P_1,P_{pub-s})$；
(4)计算群$G_T$中的元素$t=g^{h'}$；
(5)计算整数$h_1=H_1(ID_A || hid,N)$
(6)计算群$G_2$中的元素$P=[h1]P_2+P_{pub-s}$；
(7)计算群$G_T$中的元素$u=e(S',P)$；
(8)计算群$G_T$中的元素$w'=u \cdot t$,$w'$的数据类型为字符串；
(9)计算整数$h_2=H_2(M'||w',N)$。检验$h_2=h' \ \ ?$是否正确，是则通过，否则不通过。
![20220913154230](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913154230.png)
在上述签名算法的第一步和验签算法的第三和第七步为双线性对计算，它是整个算法中运算最复杂和耗时的关键步骤，其所基于的数学理论比较复杂，其中$P_1,P_2$分别为 N 阶循环群$G_1,G_2$的生成元，$P_{pub-s}$为根据签名者私钥利用椭圆曲线点乘计算得出并公开，双线性对e的值域为N阶乘法循环群$G_T$，计算结果用来后续步骤生成签名或者验证。因此可以总结出双线性对的计算会影响整个算法的实现性能。

> 模加模减、模乘、模平方以及模逆运算


## 密钥交换

参与密钥交换的发起方用户A和响应方用户B各自持有一个标识和一个相应的加密私钥，加密私钥均由密钥生成中心通过加密主私钥和用户的标识结合产生。用户A和B通过交互的信息传递，用标识和各自的加密私钥来商定一个只有他们知道的秘密密钥，用户双方可以通过可选项实现密钥确认。这个共享的秘密密钥通常用在某个对称密码算法中。该密钥交换协议能够用于密钥管理和协商

### 系统加密主密钥和用户加密密钥的产生
KGC产生随机数$ke \isin [1, N-1]$作为加密主私钥，计算$G_1$中的元素$P_{pub-e}=[ke]P_1$作为加密主公钥，则加密主密钥对为$(ke, P_{pub-e})$。KGC秘密保存ke，公开$P_{pub-e}$。
KGC选择并公开用一个字节表示的加密私钥生成函数识别符hid。
用户A和B的标识分别为$ID_A$和$ID_B$。为产生用户A的加密私钥$de_A$，KGC首先在有限域$F_N$上计算$t1=H1(I_DA||hid,N)+ke$，若t1=0则需重新产生加密主私钥，计算和公开加密主公钥，并更新已有用户的加密私钥；否则计算$t_2 = ke ∙ t_1^{-1}$，然后计算$de_A=[t_2]P_2$。为产生用户B的加密私钥$de_B$，KGC首先在有限域$F_N$
上计算$t_3=H_1(ID_B||hid,N)+ke$，若$t_3=0$则需重新产生加密主私钥，计算和公开加密主公钥，并更新已有用户的加密私钥；否则计算$t_4 = ke ∙ t_3^{-1}$，然后计算$deB=[t_4]P2$


- $r_A$:密钥交换中用户A产生的临时密钥值
- $r_B$:密钥交换中用户B产生的临时密钥值
- $SK_A,SK_B$：密钥交换协议商定的共享秘密密钥
![20220913170013](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913170013.png)



## 密钥封装机制和公钥加密算法
密钥封装机制使得封装者可以产生和加密一个秘密密钥给目标用户，而唯有目标用户可以解封装该秘密密钥，并把它作为进一步的会话密钥。
本部分规定了一个用椭圆曲线对实现的基于标识的密钥封装机制。解封装用户持有一个标识和一个相应的加密私钥，该加密私钥由密钥生成中心通过加密主私钥和解封装用户的标识结合产生。封装者利用解封装用户的标识产生并加密一个秘密密钥给对方，解封装用户则用相应的加密私钥解封装该秘密密钥。
本部分还规定了一个用椭圆曲线对实现的基于标识的公钥加密算法。该公钥加密算法是上述密钥封装机制和消息封装机制的结合，消息封装机制包括基于密钥派生函数的序列密码以及结合密钥派生函数的分组密码算法两种类型，该算法可提供消息的机密性。在基于标识的加密算法中，解密用户持有一个标识和一个相应的加密私钥，该加密私钥由密钥生成中心通过加密主私钥和解密用户的标识结合产生。加密用户用解密用户的标识加密数据，解密用户用自身加密私钥解密数据
### 系统参数组
系统参数组包括曲线识别符 cid；椭圆曲线基域 Fq的参数；椭圆曲线方程参数 a 和 b；扭曲线参数$\beta$(若 cid 的低 4 位为 2)；曲线阶的素因子 N 和相对于 N 的余因子 cf；曲线E(Fq)相对于N的嵌入次数k($q^k -1 \ mod \ N= 0$)；
$E(Fq^{d1}) $(d1 整除 k)的 N 阶循环子群$G_1$的生成元 P1；$E(Fq^{d2}) $(d2整除 k)的 N 阶循环子群$G_2$的生成元P2；
双线性对 e 的识别符 eid；(选项) 2到 1的同态映射$\psi$。
双线性对 e 的值域为 N 阶乘法循环群 T

###辅助函数
- 密码杂凑函数：如sm3
- 密码函数H1 H2 :见上文
- 密钥派生函数KDF()：见SM2算法
- 分组密码算法：分组密码算法包括加密算法Enc(K1, m)和解密算法Dec(K1,c)。Enc(K1, m)表示用密钥K1对明文m进行加密，其输出为密文比特串c；Dec(K1, c)表示用密钥K1对密文c进行解密，其输出为明文比特串m或“错误”。密钥K1的比特长度记为K1_len。
本部分规定使用国家密码管理主管部门批准的分组密码算法，如SM4分组密码算法
- 消息认证函数（MAC）
  >消息认证码函数 MAC(K2, Z)的作用是防止消息数据 Z 被非法篡改，它在密钥 K2的控制下，产生消息数据比特串 Z 的认证码，密钥 K2的比特长度记为 K2_len。在本部分的基于标识的加密算法中，消息认证码函数使用密钥派生函数生成的密钥对密文比特串求取消息认证码，从而使解密者可以鉴别消息的来源和检验数据的完整性。
    消息认证码函数需要调用密码杂凑函数。
    _密码杂凑函数为 Hv( )，其输出是长度恰为 v 比特的杂凑值。
    消息认证码函数 MAC(K2, Z)：
    输入：比特串 K2(比特长度为 K2_len 的密钥)，比特串 Z(待求取消息认证码的消息)。
    输出：长度为 v 的消息认证码数据比特串 K。
    步骤1：K=Hv(Z||K2)。_

### 密钥封装机制
##### 密钥封装算法
为了封装比特长度为klen的密钥给用户B，作为封装者的用户A需要执行以下运算步骤：
A1： 计算群 1中的元素 $QB=[H_1(ID_B||hid, N)]P1+P_{pub-e}$；
A2： 产生随机数 $r \isin [1, N-1]$；
A3： 计算群$G_1$中的元素$C=[r]Q_B$，将 C 的数据类型转换为比特串；
A4： 计算群$G_T$中的元素 $g=e(P_{pub-e}, P2)$；
A5： 计算群$G_T$中的元素 $w=g^r$，将 w 的数据类型转换为比特串；
A6： 计算$ K=KDF(C||w||ID_B, klen)$，若 K 为全 0 比特串，则返回 A2。
A7： 输出(K, C)，其中 K 是被封装的密钥，C 是封装密文
![20220913174535](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913174535.png)
##### 密钥解封装算法
用户B收到封装密文C后，为了对比特长度为klen的密钥解封装，需要执行以下运算步骤：
B1： 验证 $C \in G_1$是否成立，若不成立则报错并退出；
B2： 计算群 T中的元素 $w’=e(C, de_B)$，将 w’的数据类型转换为比特串；
B3： 将 C 的数据类型转换为比特串，计算封装的密钥 $K’=KDF(C||w’||ID_B, klen)$，若 K’为全 0 比特串，则报错并退出；
B4： 输出密钥 K’。
![20220913174714](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913174714.png)

### 公钥加密算法

#### 加密方
设需要发送的消息为比特串 M，mlen 为 M 的比特长度，K1_len 为分组密码算法中密钥 K1的比特长度，K2_len 为函数 MAC(K2, Z)中密钥 K2的比特长度
![20220913175209](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913175209.png)
#### 解密方
设 mlen 为密文 C=C1||C3||C2中 C2的比特长度，K1_len 为分组密码算法中密钥 K1的比特长度，K2_len为函数 MAC(K2, Z)中密钥 K2的比特长度
![20220913175624](https://cdn.jsdelivr.net/gh/haocat/img_bed@master/markdown/security/20220913175624.png)





## 参数定义

### 系统参数
本文使用256位的BN曲线。
- 椭圆曲线方程：$y^2 = x^3 + b$。
- 曲线参数：
- 参数 t ：60000000 0058F98A
- 迹$ tr(t) = 6t^2+1$：D8000000 019062ED 0000B98B 0CB27659
- 基域特征 $q(t) = 36t^4+ 36t^3+ 24t^2+ 6t + 1：$
  - B6400000 02A3A6F1 D603AB4F F58EC745 21F2934B 1A7AEEDB E56F9B27 E351457D
- 方程参数 b：05
  - 群的阶 $N(t) =36t^4+ 36t^3+ 18t^2+ 6t + 1：$
- B6400000 02A3A6F1 D603AB4F F58EC744 49F2934B 18EA8BEE E56EE19C D69ECF25
- 余因子 cf：1
- 嵌入次数 k：12
- 扭曲线的参数 $\beta  ：\sqrt{-2} $
- k 的因子 $d_1=1, d_2=2$
- 曲线识别符 cid：0x12
- 群$G_1$的生成元 $P_1 = (x_{P1} , y_{P1})$：
- 坐标 $x_{P1}$：93DE051D 62BF718F F5ED0704 487D01D6 E1E40869 09DC3280 E8C4E481 - 7C66DDDD
- 坐标 $y_{P1}$：21FE8DDA 4F21E607 63106512 5C395BBC 1C1C00CB FA602435 0C464CD7 - 0A3EA616
- 群$G_2$的生成元 $P2 = (x_{P2}, y_{P2})$：
- 坐标 $x_{P2}$：(85AEF3D0 78640C98 597B6027 B441A01F F1DD2C19 0F5E93C4 54806C11 - D8806141 ,
- 37227552 92130B08 D2AAB97F D34EC120 EE265948 D19C17AB F9B7213B AF82D65B )
- 坐标 $y_{P2}$：(17509B09 2E845C12 66BA0D26 2CBEE6ED 0736A96F A347C8BD 856DC76B - 84EBEB96 ,A7CF28D5 19BE3DA6 5F317015 3D278FF2 47EFBA98 A71A0811 6215BBA5 - C999A7C7 )
- 双线性对的识别符 eid：0x04